### typeof返回值
number、boolean、string、function、object、undefined

数组类型和对象类型的变量,返回object
### js数据类型
number boolean string null undefined    object（复杂类型）

### 复杂类型和基本类型的区别

 区别

1 基本数据类型把数据名和值直接存储在栈当中

  复杂数据类型在栈中存储数据名和一个堆的地址，在堆中存储属性及值，访问时先从栈中获取地址，再到堆中拿出相应的值

 2 不同数据类型作为参数时 函数内部对参数的修改是否改变外部变量的值

var num=10;//值类型,值在栈上

var obj={};//复杂类型,对象在堆,地址(引用)在栈

```javascript
function a(s){//定义以s为参数的函数，返回s的值
  s=100;
  return s;
  }
  var y=2;
  a(y);//y作为参数调用函数a
  console.log(y);//y还是为2

结果还是1因为把y的值给s时是简单的复制了一份，y和s可以单独操作不相互影响

复杂数据类型作为参数时，函数内部对参数值的修改会改变外部变量的值

因为复杂数据类型赋值是把栈中对象的地址赋给变量，函数内外两个变量指向同一个对象，所以只要对象的属性值改变，两个变量值都会改变

function student(age,name,grade){
  this.age=age;
  this.name=name;
  this.score=grade;
}

var s1=new student(18,"wjq",2);//创建一个student对象

function a(s){

   *s.name="xxx";*

**}
a(s1)//把s1赋给s
console.log(s1.name);//输出xxx**
```

所以要弄懂js中简单数据类型和复杂数据类型的区别，关键还要搞懂两个在内存中的存储过程。

### 栈和堆的区别

 栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取

### 队列和栈的区别

### a++和++a的区别
a++和++a的区别是：a++是使用的a后，再对a进行加1。++a是先把a加1，然后再使用a
### 高度塌陷是什么？引起的原因？解决办法？
* 在文档流中，父元素的高度是默认被子元素撑开的，子元素有多高，父元素就有多高。但是当子元素设置浮动后，子元素会完全脱离文档流，导致子元素无法撑起父元素的高度，造成父元素高度高度塌陷。
* 当子元素设置了float或者子元素的position属性值为absolute或是fixed，都会脱离文档流
* 解决方案
     * 给父元素加overflow: hidden
     * 给父元素添加border
     * 在父元素中内容的最后添加一个伪元素
### 事件冒泡和事件捕获
* 事件冒泡是向上
* 事件捕获是向下
### 浏览器缓存
浏览器缓存是为了重复使用而被存储的，这样可以减少服务器和客户端之间的通信次数，降低网络延迟，加速页面加载，提高用户体验
* 优点
     1. 减少了冗余的数据传输

     2. 减少了服务器的负担，大大提升了网站的性能

     3. 加快了客户端加载网页的速度

### 如何水平垂直居中
* position：absolute left top transform：translate（-50%，-50%）
* flex justify-content align-item
* flex margin:atuo
* position：absolute top: calc(50% - 50px);left: calc(50% - 50px);
### js判断数据类型
1. typeof
2. instanceof  
3. toString （最推荐） Object.prototype.toString.call(Symbol())
### 数组去重
1. set数据结构
2. instanceof（新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中）

### 作用域和作用域链

**一、作用域**

　　在 Javascript 中，作用域分为 **全局作用域** 和 **函数作用域**

　　<font color = 'red'>全局作用域：</font>

　　　　代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。

​		<font color = 'red'>函数作用域：</font>

　　　　在固定的代码片段才能被访问

**二、作用域链**

　　一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。

　　但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。

### 箭头函数和普通函数的区别

1. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是<font color=red>=></font>定义函数,普通函数是function定义函数。
2. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。
3. 箭头函数不能作为构造函数使用，也不能使用new关键字(因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会改变,作为构造函数其的this要是指向创建的新对象)。
4. 箭头函数没有自己的arguments。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。
5. call、apply、bind 并不会影响其 this 的指向。
6. 箭头函数没有原型prototype。
7. 箭头函数不能当作 Generator 函数，不能使用 yield 关键字。

### js继承方式

一、 原型链继承

![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162110117-1744170661.png)

​	重点：让新实例的原型等于父类的实例。
　　　	　特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例	的属性！）
　	　　　缺点：1、新实例无法向父类构造函数传参。
　　	　　　　　2、继承单一。
　　	　　　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属	性也会被修改！）

二、借用构造函数继承

![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162125772-1830945749.png)

　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））

​    特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
　　　　缺点：1、只能继承父类构造函数的属性。
　　　　　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　　　　　3、每个新实例都有父类构造函数的副本，臃肿。

三、组合继承（组合原型链继承和借用构造函数继承）（常用）

![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162137084-1234623120.png)

​				重点：结合了两种模式的优点，传参和复用

　　　　特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。

### call和apply区别

### 闭包

### ES6 的class 在ES5 中如何实现

### 可枚举属性和不可枚举属性

### Generator 和 async、await 的区别

### 什么是文档流

### 怎么脱离文档流

### 鼠标拖动一个元素，怎么尽量让他避免其他元素的重绘重排

### session、cookie、localstroage 的区别

### cookie 安全

### CSRF 攻击

### 跨域

